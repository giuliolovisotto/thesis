%\usepackage[utf8x]{inputenc}
\documentclass[a4paper,13pt,twoside]{article}
\usepackage[left=4cm,right=4cm,top=4cm,bottom=3cm]{geometry}
\usepackage[utf8x]{inputenc}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{fixltx2e}
\usepackage{underscore}
%\usepackage[none]{hyphenat}

\righthyphenmin 62
\lefthyphenmin 62

\include{thesis.preamble}

\begin{document}
%\begin{figure}[htpb]

%\end{figure}
\title{\LARGE {\bf Sviluppo core back-end per la configurazione del sistema e l'analisi di dati di tracking. }\\
 \vspace*{6mm}
}

\author{
Giulio Lovisotto \\ \vspace*{10mm}
Relatore: Professoressa Ombretta Gaggi \\ \vspace*{10mm}
Anno Accademico 2012/2013 \\}
\submitdate{October - November 2013}

\normallinespacing
\maketitle

%\preface
%\input{abstract/abstract}
%\input{acknowledgements/acknowledgements}
%\input{dedication/dedication}
%\input{quotes/quotes}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\body
\input{sections/introduzione}
\newpage

\input{sections/pianificazione}
\clearpage

\section{Analisi dei Requisiti} \label{sec:analisi}

\subsection{Casi d'uso} \label{sec:casiduso}
In questa sezione verranno elencati i casi d'uso del sistema che è oggetto dello stage. Dato che il sistema è stato pensato per rispondere solo all'intervento di un utente che si occupa di amministrazione e installazione l'unico attore che prenderemo in considerazione è \textbf{utente}. Per ogni caso d'uso verranno riportate:
\begin{enumerate}
\item DESCRIZIONE: contenuto del caso d'uso
\item FLUSSO PRINCIPALE DEGLI EVENTI
\item PRECONDIZIONI: asserzioni che sono valide prima dell'effettiva esecuzione del caso d'uso
\item POSTCONDIZIONI: asserzioni che sono valide dopo l'esecuzione del caso d'uso
\item SCENARI ALTERNATIVI: eventuali scenari alternativi che differiscono dal normale flusso del caso d'uso
\end{enumerate}
Ogni caso d'uso ha un identificativo stile UC\textit{n} dove n indica una posizione gerarchica.
Ogni caso d'uso è posizionato all'interno della gerarchia che parte dal caso d'uso più generale UC0 (radice dell'albero). Per ogni caso d'uso figlio valgono le precondizioni del padre.
\input{sections/casiduso}
\newpage
\subsection{Requisiti} \label{sec:req}
In questa sezione verranno elencati i requisiti software che sono emersi dai casi d'uso individuati e dalle riunioni informative con i leader dello sviluppo. Per chiarezza si è cercato di tenere un rapporto 1:1 tra casi d'uso e requisiti.
 \\ \\Nell'esposizione si userà la seguente convenzione: se un requisito padre ha figli con tipologia diversa tra di loro, il requisito padre assumerà la tipologia più vincolante tra quelle dei figli (esempio: se ci sono 2 figli, uno obbligatorio ed uno desiderabile il padre sarà qualificato come obbligatorio).
\input{sections/requisiti} 
\input{sections/trReqUc}
\newpage
\input{sections/tecnologie}
\newpage
\input{sections/problematiche}
\newpage

%%%%%%%%%%%%%%%%%%%PROGETTAZIONE DEL SISTEMA%%%%%%%%%%
\section{Progettazione} \label{sec:progett}

\subsection{Architettura Generale} \label{sec:archgen}
Le specifiche del sistema concordate con l'azienda richiedevano esplicitamente che il sistema fosse realizzato seguendo lo stile architetturale \textit{three tier} (come esplicitato nei requisiti).  \\
Dato tale vincolo si è progettato il sistema affinché esso fosse rispettato, per fare ciò si sono definiti i tre livelli del pattern (\textit{user interface, business layer, data access layer}) come i tre package di alto livello. Il package UserInterface si occuperà della presentazione dei dati e dell'interfaccia utente, il package BusinessLayer conterrà la logica dell'applicazione, il package DataAccessLayer si occuperà di fornire l'accesso ai dati dell'applicazione (contenuti in un database). Si sono ulteriormente separate le funzionalità di ciascun livello in sotto-componenti i quali raggruppano insiemi di funzionalità affini. \\
Si allega il diagramma dei package che descrive l'architettura generale dell'applicazione in figura ~\ref{fig:archgen}.\\\\
\begin{figure}[htpb]
\centering
\includegraphics[scale=0.5]{./images/archgen.png}
\caption{Diagramma dei package del sistema}
\label{fig:archgen}
\end{figure}
La motivazione di tale scelta nasce dalla necessità di voler massimizzare l'indipendenza di ogni livello rispetto al resto del sistema. Sia per quanto riguarda il livello dei dati che quello di presentazione infatti era richiesto che fossero sostituibili in blocco senza andare a modificare le altre componenti dell'applicazione. Si è preferita tale decisione per far fronte (in particolare) ad eventuali necessità di sostituzione di librerie grafiche (Qt) oppure di tipo di database, infatti il team di sviluppo non è stato in grado di garantire che MySql sarebbe riuscito a tenere dei tempi di risposta soddisfacenti all'aumentare della complessità e della cardinalità dei dati.

\subsection{Database schema} \label{sec:dbschema}
Si riporta di seguito uno schema del database utilizzato all'interno dell'applicazione per il salvataggio dei dati. \\
Sebbene alcuni dati fossero comunque legati ad una telecamera, si è scelto di separare le informazioni in tabelle diverse per coerenza e semplicità. Si sono quindi divise le informazioni riguardanti la calibrazione nella tabella \textbf{tbl_cam_calibration} e nella tabella \textbf{tbl_cam}.\\
Si riporta una breve spiegazione che motiva le scelte effettuate nella progettazione dello schema del database:
\begin{enumerate}
	\item Tra \textbf{tbl_cam} e \textbf{tbl_homographic_matrices} c'è una relazione di tipo 1:n. Si è optato per tale decisione per permettere in futuro di associare diverse \textit{homography matrix} alla stessa telecamera, ciò consente al sistema di salvare matrici diverse che esprimono relazioni diverse tra le coordinate dei punti tracciati e la loro reale rappresentazione sulla planimetria del locale. In tale modo senza perdere di consistenza si possono effettuare \textit{zoom} e rotazioni per ottenere maggiori dettagli dai dati
	\item Il campo \textbf{transformed} nella tabella \textbf{tbl_tracking_data} serve per memorizzare la condizione del dato. Infatti dato che i processi di salvataggio e successiva trasformazione non sono collegati tra di loro ma comunicano con la stessa base dati, è importante sapere se un dato è già stato "trasformato" e quindi spostato nella tabella \textbf{tbl_clean_data} oppure se tale operazione ancora non è stata eseguita. Tale campo memorizza un booleano che indica lo stato del record
	\item La tabella \textbf{tbl_clean_data} memorizza i dati di tracciamento relativi al locale nel suo complesso (la planimetria). Essa serve per modificare i dati presenti in formato \textit{raw} e slegarli dalla rispettiva telecamera dai quali sono stati catturati per renderli direttamente disponibili. In tale modo anche con un sistema funzionante con diverse telecamere si crea un dato unificato e pulito utilizzabile per la generazione delle statistiche. Similmente a quanto detto sopra il campo \textbf{synchronized} indica se il dato è già stato salvato in un sistema di backup (distribuito)
\end{enumerate}
Lo schema del database è allegato in figura ~\ref{fig:dbschema}.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{./images/dbschema.png}
\caption{Schema del database locale (MySql Workbench editor)}
\label{fig:dbschema}
\end{figure}

\newpage
\subsection{Specifica} \label{sec:specifica}
\input{sections/specifica}
\subsection{Diagrammi di sequenza} \label{sec:sequenza}
\input{sections/sequenza}
\clearpage
%%%%%%%%%%%%%%%%%%%%%END PROGETTAZIONE%%%%%%%%%%%%%%%%%%%

\section{Verifica e validazione} \label{sec:vev}
\subsection{Analisi statica} \label{sec:anstat}
\input{sections/analisistatica}

\subsection{Analisi dinamica}
Nello sviluppo del sistema si sono progettati dei test che precedessero l'implementazione di ogni componente e di ogni classe. I test di integrazione hanno definito come i vari componenti avrebbero dovuto relazionarsi tra di loro, e per ogni componente sono stati scritti adeguati test di unità che andassero a verificare il corretto funzionamento delle classi interne. Ogni unità è stata testata con un certo livello di profondità in relazione al ruolo che essa aveva all'interno del sistema, più essa era utilizzata da altre classi e più completa (in termini di coverage) era la \textit{suite} di test progettata per quell'unità. \\ \\
I test di unità in buona parte verificano il buon funzionamento del recupero dei dati dal database, mentre per i livelli piu alti essi controllano il corretto inoltro delle richieste ai livelli inferiori e la correttezza dei risultati ritornati dal livello logico. \\
Per il testing delle chiamate ai metodi forniti dalle librerie esterne si è cercato di verificare la correttezza nei limiti di risorse e tempo disponibili. Per funzionalità complesse (in particolare chiamate a metodi di OpenCV, quali calcolo matrice omografica e calibrazione telecamere, non si sono progettati test in quanto tali operazioni sono particolarmente complesse e avrebbero richiesto una profonda comprensione della teoria e quindi maggior tempo per la stesura di test efficaci. \\ \\
Il tool utilizzato per eseguire i test è stato Google Test come esposto in sezione ~\ref{sec:tecnologie}, esso si è rivelato sufficiente e completo per il tipo di verifica effettuata.
%qui ci va una sezione con test integraz/unita%
%qui ci van no i test di validazion%
\subsection{Esiti attività di verifica} \label{sec:esiti}
Di seguito vengono riportati i risultati dell'analisi statica sul codice sorgente effettuata con lo strumento CppDepend presentato in sezione ~\ref{sec:tecnologie}. Vengono riportati per ogni classe:
\begin{itemize}
	\item \textbf{Nome: } il nome della classe preceduto dall'indicazione del componente padre
	\item \textbf{ccn: } per la metrica di complessità ciclomatica viene riportato il valore ottenuto dalla media aritmetica dei vari metodi di classe (per evitare di riportare i singoli metodi)
	\item \textbf{nbloc: } per la metrica di linee di codice viene riportato il valore ottenuto dalla media aritmetica dei vari metodi di classe (per evitare di riportare i singoli metodi)
	\item \textbf{lcomhs: } il valore ottenuto dal calcolo della metrica \textit{lcomhs} che indica la coesione dei metodi di una classe.
	\item \textbf{typerank: } il valore ottenuto dal calcolo della metrica \textit{type rank}
\end{itemize}
In fase di sviluppo i limiti sull'analisi statica hanno influito in quanto alcuni metodi sono stati rivisitati per rientrare nei limiti previsti, soprattutto per aderire alla complessità ciclomatica e al numero di linee di codice accettabili. Tutti i limiti definiti in sezione ~\ref{sec:anstat} sono infine stati rispettati, quelli più immediati sono stati rispettati la scrittura del codice (numero di campi, numero di argomenti) mentre alcuni hanno comportato modifiche successive alla prima stesura per rientrare nei vincoli imposti (complessità ciclomatica, loc per metodo). Il valore di \textit{lcomhs} pari a 0 è possibile in quanto nella classe non sono presenti campi dati. Nell'ambito del progetto questo è spiegato dalla staticità dei metodi messi a disposizione da DataAccessFacade.\\ 
\input{sections/esitistatica}

\subsubsection{Tracciamento test}
\newpage
\section{Conclusioni}
\newpage
\input{bibliography/bibliography}
%\input{introduction/introduction}
%\input{background/background}

% body of thesis comes here

%\input{conclusion/conclusion}

\appendix
% appendices come here
%
%\addcontentsline{toc}{section}{Bibliography}
%\bibliographystyle{alpha}
%\bibliography{bibliography/thesis}

\end{document}
